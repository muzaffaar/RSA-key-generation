# ğŸ” RSA Key Generation & Cryptographic Demonstration

Welcome to the **RSA Key Generator** repository â€” a practical implementation and demonstration of RSA encryption, decryption, digital signatures, and signature verification using foundational number theory algorithms.

---

## ğŸ“– Overview

This project simulates the core components of RSA cryptography, including:

- Prime number generation  
- Key pair (public and private) creation  
- Message encryption and decryption  
- Digital signature creation and verification  

By leveraging classic number theory tools, this project provides a transparent, step-by-step view into how RSA works under the hood â€” ideal for learners, educators, or cryptography enthusiasts.

---

## ğŸ§  Core Concepts

### ğŸ”¢ Prime Generation
Two large prime numbers `p` and `q` are randomly selected and validated using **Miller-Rabin Primality Testing**, ensuring high confidence in primality without exhaustive checking.

### ğŸ§® Key Construction
Using `p` and `q`, the following are computed:

- **n = p Ã— q** â€” the RSA modulus  
- **Ï†(n) = (pâˆ’1)Ã—(qâˆ’1)** â€” Eulerâ€™s totient  
- **e** â€” a public exponent, chosen such that it is coprime with Ï†(n)  
- **d** â€” the private exponent, computed using the **Extended Euclidean Algorithm**  

The result: a robust RSA key pair `(public: e, n)` and `(private: d, n)`.

### ğŸ” Encryption & Decryption
- **Encryption** transforms a message using the public key.  
- **Decryption** uses the private key â€” and for performance, it applies the **Chinese Remainder Theorem** to accelerate the computation.

### âœï¸ Digital Signatures
- A **digital signature** is generated by encrypting a message with the private key.  
- **Verification** checks the signature using the public key, ensuring the message's integrity and authenticity.

---

## âš™ï¸ Algorithms Used

This project is built upon the following mathematical algorithms:

- **Miller-Rabin Test** â€“ Probabilistic primality testing  
- **Extended Euclidean Algorithm** â€“ For computing modular inverses  
- **Fast Modular Exponentiation** â€“ Efficient power computation  
- **Chinese Remainder Theorem** â€“ Optimized decryption and signature generation  
- **Basic Euclidean Algorithm** â€“ For checking coprimality  

Each algorithm is modular and designed to enhance educational clarity and maintain functional separation.

---

## ğŸ“¦ Features

- âœ… Full RSA key generation  
- âœ… Message encryption & decryption  
- âœ… Signature generation & verification  
- âœ… Clear, modular design  
- âœ… Uses pure Python (no external dependencies)  
- âœ… Great for learning cryptography from scratch  

---

## ğŸš€ Getting Started

Clone the repository, run the script, and watch as RSA magic unfolds.  
A randomly generated message is encrypted, decrypted, signed, and verified in one complete run.

---

## ğŸ§‘â€ğŸ« Educational Value

This project is ideal for:

- Computer science students  
- Cryptography learners  
- Security engineers reviewing fundamentals  
- Anyone interested in how RSA really works under the hood  

---

## ğŸ“œ License

This project is open-source and available under the [MIT License](LICENSE).

---

## ğŸ™Œ Acknowledgements

Inspired by the mathematical elegance of number theory and the enduring relevance of RSA in modern cryptography.
