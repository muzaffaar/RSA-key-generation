# 🔐 RSA Key Generation & Cryptographic Demonstration

Welcome to the **RSA Key Generator** repository — a practical implementation and demonstration of RSA encryption, decryption, digital signatures, and signature verification using foundational number theory algorithms.

---

## 📖 Overview

This project simulates the core components of RSA cryptography, including:

- Prime number generation  
- Key pair (public and private) creation  
- Message encryption and decryption  
- Digital signature creation and verification  

By leveraging classic number theory tools, this project provides a transparent, step-by-step view into how RSA works under the hood — ideal for learners, educators, or cryptography enthusiasts.

---

## 🧠 Core Concepts

### 🔢 Prime Generation
Two large prime numbers `p` and `q` are randomly selected and validated using **Miller-Rabin Primality Testing**, ensuring high confidence in primality without exhaustive checking.

### 🧮 Key Construction
Using `p` and `q`, the following are computed:

- **n = p × q** — the RSA modulus  
- **φ(n) = (p−1)×(q−1)** — Euler’s totient  
- **e** — a public exponent, chosen such that it is coprime with φ(n)  
- **d** — the private exponent, computed using the **Extended Euclidean Algorithm**  

The result: a robust RSA key pair `(public: e, n)` and `(private: d, n)`.

### 🔐 Encryption & Decryption
- **Encryption** transforms a message using the public key.  
- **Decryption** uses the private key — and for performance, it applies the **Chinese Remainder Theorem** to accelerate the computation.

### ✍️ Digital Signatures
- A **digital signature** is generated by encrypting a message with the private key.  
- **Verification** checks the signature using the public key, ensuring the message's integrity and authenticity.

---

## ⚙️ Algorithms Used

This project is built upon the following mathematical algorithms:

- **Miller-Rabin Test** – Probabilistic primality testing  
- **Extended Euclidean Algorithm** – For computing modular inverses  
- **Fast Modular Exponentiation** – Efficient power computation  
- **Chinese Remainder Theorem** – Optimized decryption and signature generation  
- **Basic Euclidean Algorithm** – For checking coprimality  

Each algorithm is modular and designed to enhance educational clarity and maintain functional separation.

---

## 📦 Features

- ✅ Full RSA key generation  
- ✅ Message encryption & decryption  
- ✅ Signature generation & verification  
- ✅ Clear, modular design  
- ✅ Uses pure Python (no external dependencies)  
- ✅ Great for learning cryptography from scratch  

---

## 🚀 Getting Started

Clone the repository, run the script, and watch as RSA magic unfolds.  
A randomly generated message is encrypted, decrypted, signed, and verified in one complete run.

---

## 🧑‍🏫 Educational Value

This project is ideal for:

- Computer science students  
- Cryptography learners  
- Security engineers reviewing fundamentals  
- Anyone interested in how RSA really works under the hood  

---

## 📜 License

This project is open-source and available under the [MIT License](LICENSE).

---

## 🙌 Acknowledgements

Inspired by the mathematical elegance of number theory and the enduring relevance of RSA in modern cryptography.
